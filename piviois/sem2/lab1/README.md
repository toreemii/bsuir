# ЛАБОРАТОРНАЯ РАБОТА №1

## Цель работы
Необходимо исследовать свойства структур данных и разработать библиотеку алгоритмов обработки структур данных.

## Условие задания
- Ориентированный граф.
- Вставка вершины.
- Удаление вершины.
- Вставка дуги.
- Удаление дуги.
- Построение дерева обхода в ширину.


## Постановка задачи
1) Разработать библиотеку для работы со структурой данных, указанной в индивидуальном задании, на любом императивном языке программирования (Pascal, C\C++, Java, C#, Python и др.).
2) Разработать тестовую программу, которая демонстрирует работоспособность реализованной библиотеки работы со структурой данных.
3) Разработать систему тестов, которые продемонстрировали бы работоспособность реализованной библиотеки. Система тестов должна отвечать требованиям полноты, адекватности и непротиворечивости. Система тестов должна учитывать не только корректную работу на правильных данных, но и предусматривать корректное завершение программы в случае некорректных данных.
4) По результатам выполнения задания составить отчет.

## Ипользуемые понятия
- **Граф** — это структура данных, состоящая из набора вершин (или узлов), связанных между собой с помощью ребера (или дуги). Графы широко применяются для исследования связей между объектами, где вершины представляют собой объекты, а ребра - связи между мертвыми объектами.
- **Ориентированный граф** — граф, рёбрам которого присвоено направление. Направленные рёбра именуются также дугами, а в некоторых источниках и просто рёбрами. Граф, ни одному ребру которого не присвоено направление, называется неориентированным графом или неорграфом.
- **Вершинa графа** — фундаментальное понятие теории графов. Неориентированный граф состоит из множества вершин и множества рёбер, в то время как ориентированный граф состоит из множества вершин и множества дуг.
- **Обход графа в ширину**.  Пусть задан невзвешенный ориентированный граф G = (V, E), в котором выделена исходная вершина s. Требуется найти длину кратчайшего пути (если таковой имеется) от одной заданной вершины до другой. Частным случаем указанного графа является невзвешенный неориентированный граф, т.е. граф, в котором для каждого ребра найдется обратное, соединяющее те же вершины в другом направлении. Для алгоритма нам потребуются очередь и множество посещенных вершин was, которые изначально содержат одну вершину s. На каждом шагу алгоритм берет из начала очереди вершину v и добавляет все непосещенные смежные с v вершины в was и в конец очереди. Если очередь пуста, то алгоритм завершает работу.
  
---

<h2> Описание алгоритмов: </h2>
<a>

  void InputMatrix()  //предназначена для чтения матрицы из файла и инициализации переменной `matrix` на основе прочитанных данных.
    {   
        string s;
        string namefile;
        cout << "Напишите файл из которого открыть";
        cin >> namefile;
        ifstream in(namefile);
        
        if (in.is_open())
        {
            getline(in, s);
            n = stoi(s.substr(0, s.size() - s.find(" ") - 1));
            m = stoi(s.substr(s.find(" ") + 1, s.size() - s.find(" ") - 1));
        }
        

        matrix.resize(n, vector<int>(m, 0));    //Инициализируем вектор векторов, создается матрица в которой каждая строка(n) имеет массив длинной m
        if (in.is_open())   
        {     
            for (int i = 0; i < n; i++) 
            {
                for (int j = 0; j < m; j++) 
                {
                    in >> matrix[i][j];
                }
            }
        }
        in.close();
    }
    /*
        Принцип работы данной функции:

    1. Создается переменная `string s` для временного хранения строк из файла, и переменная `string namefile` для хранения имени файла, которое вводит пользователь.

    2. Выводится сообщение с просьбой ввести имя файла, из которого нужно открыть матрицу.

    3. Пользователь вводит имя файла с помощью `cin >> namefile;`.

    4. Создается объект `ifstream in(namefile);`, который инициализирует поток для чтения из указанного файла.
    
    5. Проверяется, удалось ли успешно открыть файл с помощью `if (in.is_open())`. Если файл успешно открыт, то выполняется блок кода внутри `{}`.

    6. Внутри блока кода считывается первая строка из файла с помощью `getline(in, s);`. Эта строка содержит информацию о размерности матрицы, разделенную пробелом. Например, строка может быть вида "5 6", где 5 - количество вершин, а 6 - количество ребер.

    7. С помощью функции `stoi()` происходит преобразование строковых значений в числовые значения. Считанные значения присваиваются переменным `n` и `m`, которые представляют количество вершин и ребер соответственно.

    8. Инициализируется переменная `matrix` с помощью `matrix.resize(n, vector<int>(m, 0));`. Это создает матрицу с размерностью `n` x `m`, где каждый элемент инициализируется нулем.

    9. Проверяется, удалось ли успешно открыть файл еще раз с помощью `if (in.is_open())`. Если файл успешно открыт, то выполняется вложенный блок кода внутри `{}`.
    
    10. Внутри вложенного блока кода с помощью вложенных циклов `for` считывается содержимое матрицы из файла. Каждый элемент матрицы считывается с помощью `in >> matrix[i][j];`, где `i` и `j` итерируются по строкам и столбцам матрицы.

    11. Завершается чтение из файла с помощью `in.close()`.

В результате выполнения данной функции, матрица `matrix` будет инициализирована данными из файла, представляющими матрицу смежности графа.
*/

    void PrintMatrix() //предназначена для вывода матрицы инцидентности графа на экран.
    {
        cout << endl << "Матрица инцидентности:" << endl;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                cout << matrix[i][j] << " ";
            }
            cout << endl;
        }
        cout << endl;
    }
    /*
        Принцип работы данной функции:

    1. Выводится сообщение о том, что будет производиться вывод матрицы инцидентности. Например, "Матрица инцидентности:".

    2. Выполняется вложенный цикл `for`, где переменная `i` итерируется от 0 до `n-1`, а переменная `j` итерируется от 0 до `m-1`. 
    Здесь `n` и `m` предполагаемые размеры матрицы `matrix`, где `n` - количество вершин, а `m` - количество ребер.

    3. Внутри вложенного цикла выводится элемент матрицы `matrix[i][j]` с помощью `cout << matrix[i][j] << " ";`. 
    Выводимый элемент соответствует соответствующему ребру графа и может принимать различные значения в зависимости от типа графа и его свойств. 
    Например, для невзвешенного графа, 1 может означать наличие ребра, а 0 - отсутствие ребра.

    4. После завершения внутреннего цикла для каждой вершины переходим на новую строку с помощью `cout << endl;`. 
    Это позволяет выводить матрицу в виде таблицы, где каждая строка соответствует определенной вершине графа, а столбцы соответствуют ребрам.

    5. После завершения внешнего цикла выводится пустая строка для разделения матрицы от другого вывода или текста.
    */

    void AddVertex() //предназначена для добавления новой вершины в граф, представленный матрицей смежности.
    {
        vector<int> newVertex(m, 0);
        matrix.push_back(newVertex);
        n++;
        cout << "Вершина добавлена." << endl << endl;
    }
    /*
     Принцип работы данной функции:

    1. Создается новый вектор `newVertex` типа `vector<int>`, инициализированный нулями. Размер этого вектора равен `m`, причем `m` предполагается, что это количество вершин в графе.

    2. Вектор `newVertex` добавляется в конец матрицы смежности `matrix` с помощью `matrix.push_back(newVertex)`. Теперь новая вершина представлена в матрице смежности.

    3. Значение `n`, предполагаемое количество вершин в графе, увеличивается на единицу (`n++`).

    4. Выводится сообщение о том, что вершина была успешно добавлена.
    */

    void DelVertex()    // предназначена для удаления вершины из графа, представленного матрицей смежности.
    {
        int numVertex;
        cout << endl << "Выберите вершину, которую хотите удалить: " << endl;
        cin >> numVertex;

        if (numVertex >= 0 && numVertex < matrix.size()) {
            matrix.erase(matrix.begin() + numVertex);
            cout << "Вершина " << numVertex << " удалена." << endl;
            n--;
        }
        else {
            cout << "Недопустимый индекс для удаления элемента." << endl;
        }
    }
    /*
        Принцип работы данной функции:

    1. Пользователю выводится сообщение с просьбой выбрать вершину, которую он хочет удалить.

    2. Пользователь вводит индекс удаляемой вершины (`numVertex`) с помощью `cin >> numVertex;`.

    3. Проверяется, что введенный индекс вершины находится в допустимых пределах матрицы смежности. 
    Условие `(numVertex >= 0 && numVertex < matrix.size())` проверяет, что значение `numVertex` больше или равно нулю и меньше размера матрицы.

    4. Если введенный индекс вершины допустим, то происходит удаление вершины из матрицы смежности. 
    С помощью `matrix.erase(matrix.begin() + numVertex - 1)` элемент, находящийся на индексе `numVertex - 1`, удаляется из матрицы `matrix`.

    5. Выводится сообщение о том, что вершина с индексом `numVertex` была успешно удалена.

    6. Значение `n`, предполагаемое количество вершин в графе, уменьшается на единицу (`n--`).

    7. Если введенный индекс вершины недопустим, выводится сообщение о недопустимости индекса для удаления элемента.
    */

    void AddArc()   //функция AddArc() предназначена для добавления дуги (направленного ребра) в граф, представленный матрицей смежности.
    {
        int fromVertex, toVertex;
        cout << endl << "Введите 2 вершины, от которой и до которой будет проведена дуга: " << endl;
        cin >> fromVertex >> toVertex;

        if ((fromVertex >= 0 && fromVertex < matrix.size()) && (toVertex >= 0 && toVertex < matrix.size()))
        {
            for (int i = 0; i < n; i++)
            {
                if (i == fromVertex - 1)
                {
                    matrix[i].push_back(1);
                }
                else if (i == toVertex - 1)
                {
                    matrix[i].push_back(-1);
                }
                else
                {
                    matrix[i].push_back(0);
                }
            }
            m++;
        }
        cout << "Дуга от вершины " << fromVertex << " до вершины " << toVertex << " добавлена." << endl;
    }
    /*
    Принцип работы функции:

    1.Пользователю выводится сообщение с просьбой ввести две вершины, между которыми будет проведена дуга.

    2.Пользователь вводит значения двух вершин (fromVertex и toVertex) с помощью функции cin >> fromVertex >> toVertex;.

    3.Проверяется, что введенные значения вершин находятся в допустимых пределах матрицы смежности. 
    Условие (fromVertex >= 0 && fromVertex < matrix.size()) && (toVertex >= 0 && toVertex < matrix.size()) проверяет, что значения fromVertex и toVertex больше или равны нулю и меньше размера матрицы.

    4.Если введенные значения вершин допустимы, то происходит добавление дуги в матрицу смежности. 
    Для этого происходит итерация по всем вершинам графа с помощью цикла for (int i = 0; i < n; i++), где n - количество вершин в графе.
    
    5.Внутри цикла проверяется, находится ли текущая итерируемая вершина (i) на позиции fromVertex - 1 или toVertex - 1. 
    Если вершина находится на позиции fromVertex - 1, то в соответствующий столбец этой вершины в матрице добавляется значение 1 с помощью matrix[i].push_back(1). 
    Если вершина находится на позиции toVertex - 1, то в соответствующий столбец этой вершины в матрице добавляется значение -1 с помощью matrix[i].push_back(-1). 
    В противном случае, в столбец текущей вершины добавляется значение 0 с помощью matrix[i].push_back(0).
   
    6.После завершения цикла значения fromVertex и toVertex добавлены в матрицу смежности, и переменная m (предположительно, отслеживающая количество дуг в графе) увеличивается на единицу (m++).
    
    7.Выводится сообщение о том, что дуга от вершины fromVertex до вершины toVertex была успешно добавлена.
    */
    void DelArc()
    {
        int numArc;
        cout << endl << "Введите номер дуги, которую хотите удалить: " << endl;
        cin >> numArc;

        if (numArc >= 0 && numArc < m)
        {
            for (int i = 0; i < n; i++)
            {
                if (matrix[i][numArc] != 0)
                {
                    matrix[i].erase(matrix[i].begin() + numArc);
                }
            }
            m--;
            cout << "Дуга удалена." << endl;
        }
        else
        {
            cout << "Недопустимый индекс дуги." << endl;
        }
    }
    /*
    Принцип работы данной функции:

    1. Создается переменная `int numArc` для хранения номера дуги, которую пользователь хочет удалить.

    2. Выводится сообщение с просьбой ввести номер дуги, которую нужно удалить.

    3. Пользователь вводит номер дуги с помощью `cin >> numArc;`.

    4. Выполняется условная проверка `if (numArc >= 0 && numArc <= matrix[0].size())`, чтобы убедиться, что введенный номер дуги находится в допустимом диапазоне для матрицы инцидентности.

    5. Если номер дуги находится в допустимом диапазоне, то выполняется блок кода внутри `{}`.

    6. Внутри блока кода происходит итерация по каждой строке матрицы с помощью цикла `for (int i = 0; i < n; i++)`.

    7. Внутри цикла вызывается функция `erase()` для удаления элемента с указанным номером дуги из каждой строки матрицы. 
    Выражение `matrix[i].erase(matrix[i].begin() + numArc - 1)` удаляет элемент из вектора `matrix[i]` с индексом `numArc - 1`. 
    Обратите внимание, что индексация элементов начинается с 0, поэтому для удаления дуги с номером 1, необходимо использовать `numArc - 1`.

    8. После удаления дуги из каждой строки матрицы, уменьшается количество ребер `m` на 1 с помощью операции `m--`, так как одна дуга была удалена.

    9. Выводится сообщение о том, что дуга успешно удалена.

    10. Если номер дуги не находится в допустимом диапазоне, то выполняется блок кода внутри `else`.

    11. Внутри блока кода выводится сообщение о недопустимом индексе.
    */


    int BFS()
    {
        cout << "Начало выполнения функции обхода в ширину:" << endl;
        for (int i = 0; i < n; i++) {
            vector<bool> visited(n, false);
            queue<pair<int, int>> q;
            q.push({ i, 0 });

            while (!q.empty()) {
                int cur = q.front().first;
                int dist = q.front().second;
                q.pop();

                for (int j = 0; j < m; j++) {
                    if (matrix[cur][j] == 1) {
                        for (int neighbor = 0; neighbor < n; neighbor++) {
                            if (matrix[neighbor][j] == -1) {
                                if (neighbor == i) {
                                    cout << "Вершина " << neighbor << " посещена" << endl;
                                }
                                else if (!visited[neighbor]) {
                                    visited[neighbor] = true;
                                    q.push({ neighbor, dist + 1 });
                                    cout << "Вершина " << neighbor << " посещена" << endl;
                                }
                            }
                        }
                    }
                }
            }
        }
        cout << "Функция обхода в ширину закончена." << endl;
        return 1;
    }
    /*
       Принцип работы данной функции:

     1. Выводится сообщение о начале выполнения функции обхода в ширину.

     2. Внешний цикл `for (int i = 0; i < n; i++)` выполняется для каждой вершины графа.

    3. Внутри цикла создается вектор `visited` размером `n`, который инициализируется значением `false`. Вектор `visited` используется для отслеживания посещенных вершин.
    
    4. Создается очередь `q` с элементами типа `pair<int, int>`, где первый элемент - номер вершины, а второй элемент - расстояние от исходной вершины.

    5. В очередь `q` добавляется пара значений `{i, 0}`, где `i` - номер текущей вершины, а `0` - начальное расстояние от текущей вершины.
 
     6. Запускается цикл `while (!q.empty())`, который выполняется до тех пор, пока очередь не станет пустой.

     7. Извлекается первый элемент из очереди с помощью `q.front()`, и его значения присваиваются переменным `cur` (текущая вершина) и `dist` (расстояние от исходной вершины).
 
    8. Итерируется цикл `for (int j = 0; j < m; j++)` по всем ребрам, связанным с текущей вершиной.

    9. Если существует ребро между текущей вершиной `cur` и вершиной `neighbor` (проверяем `matrix[cur][j] == 1`), то запускается вложенный цикл `for` для перебора всех вершин `neighbor`, связанных с ребром.

    10. Если встречается вершина `neighbor`, помеченная значением `-1` (проверяем `matrix[neighbor][j] == -1`), то выполняется следующее:

    - Если `neighbor` равна исходной вершине `i`, то выводится сообщение о посещении вершины.
    - В противном случае, если `neighbor` еще не была посещена (`!visited[neighbor]`), то она помечается как посещенная (`visited[neighbor] = true`) и добавляется в очередь `q` с расстоянием `dist + 1`.

    11. По окончании внутреннего цикла, все вершины, достижимые из текущей вершины `cur`, обрабатываются.

    12. Переход к следующей итерации внешнего цикла, где выбирается следующая вершина и процесс повторяется.

    13. Выводится сообщение о завершении функции обхода в ширину.

    14. Возвращается значение `1`.

        В результате выполнения функции `BFS()`, будет выполнен обход графа в ширину, начиная с каждой вершины, и будет выведено сообщение о посещении каждой достижимой вершины.
    */

  в конце в файле lab1.cpp мы подключаем наш заголовочный файл, и реализуем через "switch" меню нашей программы, где в каждом "case" вызываем соответствующую функцию
</a>


---

## Вывод
В результате выполнения лабораторной работы был успешно разработан и применён механизм алгоритмов обработки структуры данных.

## Использованная литература
1) Долинский М.С. Решение сложных и олимпиадных задач по программированию: Учебное пособие. — СПб.: Питер, 2006. — 366 с.: ил.
2) Седжвик Р. Фундаментальные алгоритмы C++. Анализ/Структуры данных/Сортировка/Поиск: Пер. с англ./Седжвик Р.-К.: Издательство "ДиаСофт", 2001. — 688с.
